using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Text.RegularExpressions;

static class ЗаголовочныйФайл
{
    public static string Преобразовать(string оригинальныйИсходник)
    {
        // Чтобы упростить регулярные выражения и обобщить скрипт на все платформы.
        string результат = оригинальныйИсходник.Replace("\r\n", "\n");

        // Регексы проще реализовать, если сначала убрать все лишнее.
        string очищенныйИсходник = Очистить(результат);

        // Отладка.
        //return очищенныйИсходник;

        // Находим в заголовочном файле все функции, модифицируем их и вставляем назад в файл.
        // Регексы проще реализовать, если сначала в исходнике найти классы, а затем в этих классах искать функции.
        // К тому же для модификации функций необходимо знать названия классов.
        // Поэтому был добавлен отдельный класс "Класс" :)
        Класс[] классы = НайтиКлассы(очищенныйИсходник);
        foreach (Класс класс in классы)
        {
            string[] оригинальныеФункции = класс.НайтиФункции();
            for (int i = 0; i < оригинальныеФункции.Length; i++)
            {
                string оригинальнаяФункция = оригинальныеФункции[i];
                string преобразованнаяФункция = класс.ПреобразоватьФункцию(оригинальнаяФункция);
                результат = результат.Replace(оригинальнаяФункция, преобразованнаяФункция);
            }
        }

        return результат;
    }

    private static string Очистить(string исходник)
    {
        // Удаляем комментарии. *? - ленивый квантор.
        string однострочныйКомментарий = @"//.*?\n";
        string многострочныйКомментарий = @"/\*.*?\*/";
        string шаблон = однострочныйКомментарий + "|" + многострочныйКомментарий;
        исходник = Regex.Replace(исходник, шаблон, "\n", RegexOptions.Singleline);

        // Удаляем все #pragama.
        // \s включает в себя \n, поэтому вместо \s используем [ \t] для пробельных символов.
        шаблон = @"\#pragma[ \t].*?\n";
        исходник = Regex.Replace(исходник, шаблон, "", RegexOptions.Singleline);

        // Удаляем все #include.
        шаблон = @"\#include[ \t].*?\n";
        исходник = Regex.Replace(исходник, шаблон, "", RegexOptions.Singleline);

        // Извлекаем тело namespace Urho3D {}.
        шаблон = @"namespace\s+Urho3D\s*"
               + @"{"
               + @"("                        // Содержимое будет сохранено в $1.
               +     @"(?:"
               +         @"[^{}]"            // Любой символ, кроме скобок.
               +         @"|(?'BRACKET'{)"   // Или открывающая скобка. Тогда создаем подгруппу.
               +         @"|(?'-BRACKET'})"  // Или закрывающая скобка. Тогда удаляем подгруппу, возвращаясь на уровень выше.
               +     @")+"
               + @")"
               + @"(?(BRACKET)(?!))"         // Если определен BRACKET, значит скобки не сбалансированы.
                                             // При этом срабатывает (?!), который всегда возвращает ошибку.
               + @"}";
        Match соответствие = Regex.Match(исходник, шаблон, RegexOptions.Singleline);
        if (!соответствие.Success)
            throw new Exception("Не найдено namespace Urho3D {}");
        исходник = соответствие.Result("$1");

        // Удаляем многострочные #define \
        шаблон = @"\#define[ \t][^\n]*\\[ \t]*\n" // Первая строка #define ... \
               + @"(?:[^\n]*\\[ \t]*\n)*"         // Любое число строк, которые оканчиваются на \
               + @"[^\n]*(?!\\[ \t]*)\n";         // И последняя строка, которая не оканчивается на \
        исходник = Regex.Replace(исходник, шаблон, "", RegexOptions.Singleline);

        // Удаляем однострочные #define.
        шаблон = @"\#define[ \t].*?\n";
        исходник = Regex.Replace(исходник, шаблон, "", RegexOptions.Singleline);

        // Удаляем template class {}; и template struct {};
        шаблон = @"template\s*<[^{}()]+"
               + @"{"
               + @"(?:"
               +     @"[^{}]"
               +     @"|(?'BRACKET'{)"
               +     @"|(?'-BRACKET'})"
               + @")+"
               + @"(?(BRACKET)(?!))"
               + @"};";
        исходник = Regex.Replace(исходник, шаблон, "", RegexOptions.Singleline);

        // Удаляем template function() {} (то есть без ; в конце и с круглыми скобками в начале).
        шаблон = @"template\s*<[^{}()]+\([^{}()]*\)[^{};]*"
               + @"{"
               + @"(?:"
               +     @"[^{}]"
               +     @"|(?'BRACKET'{)"
               +     @"|(?'-BRACKET'})"
               + @")+"
               + @"(?(BRACKET)(?!))"
               + @"}";
        исходник = Regex.Replace(исходник, шаблон, "", RegexOptions.Singleline);

        // Удаляем template<...; (то есть без фигурных скобок и с ; в конце).
        шаблон = @"template\s*<.*?;";
        исходник = Regex.Replace(исходник, шаблон, "", RegexOptions.Singleline);

        return исходник;
    }

    private static Класс[] НайтиКлассы(string очищенныйИсходник)
    {
        string шаблон = @"class\s+URHO3D_API\s+[^{};]+"
                      + @"{"
                      + @"(?:"
                      +     @"[^{}]"
                      +     @"|(?'BRACKET'{)"
                      +     @"|(?'-BRACKET'})"
                      + @")+"
                      + @"(?(BRACKET)(?!))"
                      + @"};";
        MatchCollection соответствия = Regex.Matches(очищенныйИсходник, шаблон, RegexOptions.Singleline);
        Класс[] результат = new Класс[соответствия.Count];
        for (int i = 0; i < результат.Length; i++)
            результат[i] = new Класс(соответствия[i].Value);
        return результат;
    }
}
